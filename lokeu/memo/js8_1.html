<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        /*
            [8.1] 프로토타입 상속
        */

        // let animal = {
        //     eats: true,
        //     walk() {
        //         alert("동물이 걷습니다.");
        //     }
        // };

        // let rabbit = {
        //     jumps: true,
        //     __proto__: animal,
        // };

        // let longEar = {
        //     earLength: 10,
        //     __proto__: rabbit
        // };

        // longEar.walk();
        // alert(longEar.jumps);

        // 프로토 타입은 읽을 때만 사용.
        // 프로퍼티를 추가, 수정하거나 지우는 연산은 객체에 직접 해야한다.

        // let animal = {
        //     eat: true,
        //     walk() {

        //     }
        // };

        // let rabbit = {
        //     __proto__: animal
        // };

        // rabbit.walk = function(){
        //     alert("토끼가 깡충깡충 뜁니다.");
        // }

        // rabbit.walk();


        // let user = {
        //     name: "john",
        //     surname: "Smith",

        //     set fullName(value) {
        //         [this.name, this.surname] = value.split(" ");
        //     },

        //     get fullName() {
        //         return `${this.name} ${this.surname}`;
        //     }
        // };

        // let admin = {
        //     __proto__: user,
        //     isAdmin: true
        // };

        // alert(admin.fullName);

        // admin.fullName = "Alice Cooper";

        // alert(admin.fullName);
        // alert(user.fullName);

        // this는 프로토 타입에 영향을 받지 않는다.
        // this는 메서드 객체에서 호출했든 프로토타입에서 호출했든 상관없이 this는 언제나 . 앞에 있는 객체가 된다.

        // 실제 메서드가 호출되는 시점을 기억하자.

        let animal = {
            eats: true
        };

        let rabbit = {
            jumps: true,
            __proto__: animal,
        };

        // alert(Object.keys(rabbit));
        // for(let prop in rabbit) alert(prop);

        // obj.hasOwnProperty(key)를 이용하면 상속프로퍼티를 순회 대상에서 제외할 수 있다.

        for(let prop in rabbit) {
            let isOwn = rabbit.hasOwnProperty(prop);

            if(isOwn) {
                alert(`객체 자신의 프로퍼티: ${prop}`);
            } else {
                alert(`상속 프로퍼티: ${prop}`);
            }
        }




        let head = {
            glasses: 1
        };

        let table = {
            pen: 3,
            __proto__: head
        };

        let bed = {
            sheet: 1,
            pillow: 2,
            __proto__: table
        };

        let pockets = {
            money: 2000,
            __proto__: bed
        };






    </script>
</body>
</html>