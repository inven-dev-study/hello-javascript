객체
object 

자바스크립트에는 여덟가지 자료형이 있으며
그 중, 오직 하나의 데이터(문자열, 숫자 등)만을 담을 수 있는 일곱개의 자료형을 '원시형' 이라 부른다.

다른 하나의 자료형인 '객체형'은 원시형과 달리 다양한 데이터를 담을 수 있다.

객체는 중괄호를 이용해 만들 수 있으며 키:값 쌍으로 이루어진 프로퍼티를 여러 개 담을 수 있다.
객체에서는 키를 이용해 프로퍼티를 쉽게 읽고, 추가, 삭제할 수 있다.

```
let object = {
    key : value,
    key : value,  // *마지막 프로퍼티의 끝은 쉼표로 끝날 수 있다.
};

* 끝에 쉼표를 붙이면 모든 프로퍼티가 유사한 형태를 보이기 때문에
  프로퍼티를 추가, 삭제, 이동하는 것이 쉬워진다.
```


==========
빈 객체를 만드는 방법
```
1. 객체 생성자 문법
    let user = new Object();
2. 객체 리터럴 문법
    let user = {};
```
==========

점 표기법을 이용하여 프로퍼티의 값을 읽을 수 있다.
```
alert( user.name );
alert( user.age );
```

==========
프로퍼티 이름에 공백을 포함하는 경우에는 따옴표로 묶어주어야 한다.
```
"likes birds" : true,
```
*이 경우 점 표기법으로 프로퍼티 값을 읽는 것이 불가능하다.
점 표기법은 '유효한 식별자'인 경우에만 사용할 수 있다.
[ERROR] user.likes birds = true

**유효한 식별자: 공백이 없고, 숫자로 시작하지 않으며, $ _ 을 제외한 특수문자가 없어야 한다.

==========
키가 유효한 식별자가 아닌 경우에는 대괄호 표기법을 이용할 수 있다.
```
alert(user["likes birds"]);
```
* 문자열을 사용할 때는 문자열을 따옴표로 묶어주어야 한다.

대괄호 표기법을 이용하면 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있다.
```
let user = {
  name: "John",
  age: 30
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

// 변수로 접근
alert( user[key] ); // John (프롬프트 창에 "name"을 입력한 경우)
```

> 계산된 프로퍼티
 : 객체 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우
```
let bag = {
    [fruit]: 5,
}
이 경우, [fruit]는 변수 fruit 에서 프로퍼티 이름을 가져오겠다는 것을 의미한다.
```

---
대괄호 표기법은 제약을 없애주는 강력한 기능이 있지만 작성하기 번거롭다는 단점이 있다.

==========
단축 프로퍼티
```
function user(name, age) {
    return {
        name: name,
        age: age,
    }
}
```
위와 같이 프로퍼티의 이름과 값이 변수명과 동일한 경우
아래와 같이 단축구문을 사용하여 표현할 수 있다.
```
function user(name, age) {
    return {
        name,
        age,
    }
}
```

==========
객체 프로퍼티에는 이름에 대한 제약이 없어서
for, let, return 과 같은 예약어도 사용할 수 있다.
또한, 어떠한 문자형, 심볼형 값도 프로퍼티 이름이 될 수 있다.
문자형이나 심볼형이 아닌 값은 문자열로 형변환된다.
```
let obj = {
    0: "test"  // == "0": "test"    // obj["0"] == obj[0]
}
```

단 __proto__ 라는 이름은 특별한 취급을 받는다.
==========
'in' 연산자를 통해 프로퍼티의 존재 여부를 확인할 수 있다.
```
"key" in object  // true or false
```
==========
'for...in' 반복문
for...in 반복문을 사용하여 객체의 모든 키를 순회할 수 있다.
```
for (key in object) {
    alert( key );  // 키 값
    alert( user[key] );  // 키에 해당하는 밸류 값
}
```
==========
객체 정렬 방식
> 정수 프로퍼티는 자동 정렬되고
> 그 외의 프로퍼티는 객체에 추가한 순서대로 정렬된다.

? 정수프로퍼티
아무런 변형 없이 정수로 반환되는 문자열
==========
==========
참조에 의한 객체 복사

원시형은 "값 그대로" 저장, 할당되는 반면 객체는 참조에 의해 저장되고 복사된다.

변수에 객체를 할당하면, 객체 그대로 저장되는 것이 아니라
객체가 저장되어 있는 '메모리 주소'에 대한 '참조 값'이 저장된다.
따라서 객체가 할당된 변수를 복사하면 객체 자체가 복사되는 것이 아니라 참조 값만 복사된다.
```
let user = {name: 'john'};
let admin = user;
admin.name = 'pete';
alert(user.name);  // admin에서 변경한 name인 'pete'가 출력된다.
=> user === admin  // true;
```

==========
객체 복사, 병합과 Object.assign

* 객체를 복사할 일은 거의 없다.
** 자바스크립트는 객체 복사 내장 메소드를 지원하지 않는다.

▼ 새로운 객체를 만든 후 기존 객체의 프로퍼티를 순회해 원시 수준까지 프로퍼티를 복사한다.
```
let user = {name: "john"};
let clone = {};  // 새로운 빈 객체 생성

for (let key in user) {
    clone[key] = user[key];
}
```

▼Object.assign 을 이용할 수 있다.

`Object.assign(dest, [src1, sr2, src3...])`
* dest => 목표 객체
** src1 ... => 복사하고자 하는 객체
```
let user = {name: 'john'};
let permission1 = {canView: true};
let permission2 = {canEdit: true};

Object.assign(user, permission1, permission2);

// user = {name: 'john', canView: true, canEdit: true};
```
*목표 객체에 동일한 이름의 프로퍼티가 있는 경우에는 덮어씌워지게 된다.
```
let user = {name: 'john'};
let clone = Object.assign({}, user);
```
*객체의 프로퍼티에 다른 객체가 있는(객체가 이중으로 있는) 경우
이 방법(얕은복사)으로는 객체를 완전히 복사할 수 없다.
깊은 복사를 하려면, 알고리즘을 이용하거나 lodash 라이브러리의 _.cloneDeep(obj)를 이용하면 처리할 수 있다.

